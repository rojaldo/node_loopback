:source-highlighter: highlight.js
= Loopback
:icons: font
:toc: left
:toclevels: 2

== 1. Introducción a Loopback

=== ¿Qué es Loopback?
Loopback es un framework de Node.js diseñado para construir APIs RESTful de forma rápida y eficiente. Se basa en una arquitectura modular que permite la integración de múltiples fuentes de datos y facilita tareas comunes en el desarrollo backend, como validaciones, autenticación, y manejo de errores.

=== Historia y Evolución del Framework
Loopback inició como un proyecto de IBM para simplificar el desarrollo de backends para aplicaciones móviles y web. Con el tiempo, ha evolucionado incorporando mejoras tecnológicas y nuevas funcionalidades, convirtiéndose en una herramienta robusta y versátil que se adapta a las necesidades del desarrollo ágil y la integración de servicios modernos.

=== Ventajas y Casos de Uso
Loopback presenta varias ventajas:
* **Generación Automática de APIs:** Permite definir modelos de datos que se transforman automáticamente en endpoints RESTful.
* **Flexibilidad en la Conexión de Datos:** Facilita la integración con bases de datos SQL y NoSQL, así como con servicios externos.
* **Seguridad Integrada:** Ofrece mecanismos para autenticación y autorización de manera nativa.
* **Comunidad y Soporte:** Cuenta con una comunidad activa y extensa documentación, lo que facilita la resolución de problemas y la implementación de casos complejos.

*Casos de Uso Comunes:*
* Desarrollo de microservicios.
* Creación de backends para aplicaciones móviles y web.
* Integración de múltiples fuentes de datos en entornos empresariales.
* Proyectos que requieren escalabilidad y una rápida generación de APIs.

== 2. Instalación y Configuración Inicial

=== Requisitos previos: Node.js y npm
.Antes de comenzar, asegúrate de tener instalados Node.js y npm (Node Package Manager). Puedes verificar su instalación ejecutando los siguientes comandos en la terminal:
[source, shell]
----
node --version
npm --version
----
Si no están instalados, descárgalos e instálalos desde [https://nodejs.org](https://nodejs.org).

=== Instalación del Loopback CLI
.Loopback CLI es una herramienta de línea de comandos que facilita la creación y gestión de proyectos Loopback. Para instalarlo globalmente, ejecuta:
[source, shell]
----
npm install -g @loopback/cli
----
.Verifica la instalación con:
[source, shell]
----
lb4 --help
----

=== Creación y configuración de un proyecto Loopback
Una vez instalado el CLI, crea un nuevo proyecto Loopback siguiendo estos pasos:

.Ejecuta el comando: 
[source, shell]
----
   lb4 app
----

.Introduce el nombre del proyecto y responde a las preguntas de configuración (tipo de aplicación, integración con bases de datos, etc.)
[source, shell]
----
Project name: getting-started
? Project description: Getting started tutorial
? Project root directory: getting-started
? Application class name: StarterApplication
? Select features to enable in the project:
❯◉ Enable eslint: add a linter with pre-configured lint rules
 ◉ Enable prettier: install prettier to format code conforming to rules
 ◉ Enable mocha: install mocha to run tests
 ◉ Enable loopbackBuild: use @loopback/build helpers (e.g. lb-eslint)
 ◉ Enable editorconfig: add EditorConfig files
 ◉ Enable vscode: add VSCode config files
 ◉ Enable docker: include Dockerfile and .dockerignore
 ◉ Enable repositories: include repository imports and RepositoryMixin
 ◉ Enable services: include service-proxy imports and ServiceMixin
----

Al terminar, se habrá generado la estructura básica del proyecto, incluyendo carpetas para modelos, controladores y repositorios.

.Revisa el archivo `package.json` y utiliza el comando:
[source, shell]
----
npm start
----
para iniciar el servidor y verificar que el entorno esté configurado correctamente.

=== Creación de un Controller

.Para crear un controlador básico, utiliza el comando:
[source, shell]
----
lb4 controller
----

.Introduce el nombre del controlador y selecciona el tipo de controlador (REST, GraphQL, etc.). Por ejemplo:
[source, shell]
----
? Controller class name: hello
? What kind of controller would you like to generate? Empty Controller
  create src/controllers/hello.controller.ts
  update src/controllers/index.ts

Controller hello was now created in src/controllers/
----

.En el archivo generado, define un método simple que responda a una solicitud GET:
[source, javascript]
----
import {get} from '@loopback/rest';

export class HelloController {
  @get('/hello')
  hello(): string {
    return 'Hello world!';
  }
}
----

Prueba el endpoint accediendo a `http://localhost:3000/hello` en tu navegador o utilizando herramientas como Postman.

=== Creación de un servicio

Para crear un servicio en Loopback, utiliza el CLI de Loopback y ejecuta el siguiente comando:

[source, shell]
----
lb4 service [opciones] [nombre del servicio]
----

A continuación, se te indicará configurar el servicio mediante una serie de preguntas, como:
* Nombre del servicio.
* Tipo de servicio (por ejemplo, servicio personalizado para lógica de negocio o integración con APIs externas).
* Ruta de ubicación del archivo generado.

.Las opciones pueden incluir:
* `--type`: Especifica el tipo de servicio (por ejemplo, `custom`, `external`).
* `--datasource`: Indica la fuente de datos a la que se conectará el servicio, que se sepecifica en src/datasources.

.Hay 3 tipos de servicios que puedes crear:
* `proxy`: Para crear un servicio proxy que se conecte a un servicio externo remoto REST, SOAP, gRPC, etc. Tiene que haber un datasource configurado en src/datasources.
* `class`: Para crear un servicio de clase que encapsule la lógica de negocio.
* `provider`: Para crear un servicio que proporcione datos o lógica a otros componentes de la aplicación.

Una vez completado, se creará un archivo en el directorio `src/services/`, que contendrá la estructura básica del servicio. Por ejemplo, si creas un servicio llamado `MyService`, el archivo generado podría tener el siguiente contenido:

[source, ts]
----
export class MyService {
  constructor() {
    // Inicialización del servicio
  }

  /**
   * Método que implementa la lógica del servicio.
   * @param input Entrada para procesar
   * @returns Resultado procesado
   */
  process(input: string): string {
    // Lógica del servicio
    return `Resultado: ${input}`;
  }
}
----

Este servicio se puede inyectar en controladores u otros componentes mediante el sistema de inyección de dependencias de Loopback. Por ejemplo, para usar el servicio en un controlador, puedes hacerlo de la siguiente manera:

[source, ts]
----
import {inject} from '@loopback/core';
import {MyService} from '../services';

export class MyController {
  constructor(
    @inject('services.MyService') // Asegúrate de registrar el servicio
    private myService: MyService,
  ) {}

  // Ejemplo de endpoint que utiliza el servicio
  async ejemploEndpoint(): Promise<string> {
    const resultado = this.myService.process('Entrada de ejemplo');
    return resultado;
  }
}
----

Con estos pasos, habrás creado e integrado correctamente un servicio en tu aplicación Loopback, lo que te permitirá encapsular y reutilizar lógica de negocio de forma modular y eficiente.

=== Creación de un datasource

Un datasource en Loopback es una configuración que define cómo se conecta la aplicación a una fuente de datos, como una base de datos SQL o NoSQL. Para crear un datasource.
.Para usar el CLI de Loopback y ejecuta el siguiente comando:
[source, shell]
----
lb4 datasource [options] [<name>]
----

.Las opciones pueden incluir:
* `--connector`: Especifica el conector a utilizar (por ejemplo, `mysql`, `mongodb`, `postgresql`, etc.).
* `--config`: Permite especificar un archivo de configuración para el datasource.
* `--skip-cache`: Evita que se genere un archivo de caché para el datasource.
* `--skip-install`: Evita la instalación de dependencias adicionales.
* `--format`: Permite especificar el formato del código generado.
* `--yes`: Acepta todas las opciones por defecto sin preguntar.
* `--help`: Muestra la ayuda del comando.



== 3. Arquitectura de Loopback

La arquitectura de Loopback está pensada para aportar una estructura organizada y escalable, facilitando la separación de responsabilidades y la integración con diversas fuentes de datos.

=== Estructura de un proyecto Loopback
Un proyecto Loopback típico se organiza en una serie de carpetas que ayudan a mantener el código modularizado y fácil de mantener. Algunas de las carpetas y archivos principales son:

* **src/**: Contiene el código fuente de la aplicación.
  * **models/**: Define los modelos de datos que representan las entidades del dominio.
  * **controllers/**: Gestiona la lógica de negocio y responde a las solicitudes HTTP.
  * **repositories/**: Encapsula la lógica de acceso y manipulación de datos, facilitando la conexión con bases de datos u otros servicios.
  * **datasources/**: Configura las conexiones a las bases de datos y otros proveedores de datos.
  * **routes/** (opcional): Define rutas y mapea endpoints a controladores, en caso de querer una organización adicional.
* **package.json**: Archivo de configuración de Node.js, que incluye dependencias y scripts de arranque.
* **.env**: Archivo opcional para definir variables de entorno que configuran aspectos del entorno de ejecución (por ejemplo, detalles de conexión a bases de datos).

Esta estructura permite que cada componente de la aplicación tenga un rol definido y se integre de forma coherente en el conjunto del proyecto.

=== Componentes principales: Controladores, Repositorios, Modelos, Servicios, Datasources
El diseño modular de Loopback se basa en tres componentes esenciales:

* **Controladores:**  
  Encargados de manejar las solicitudes HTTP, los controladores contienen la lógica de negocio de la aplicación. Se comunican con los repositorios para recuperar o modificar datos y devuelven respuestas adecuadas a los clientes.

* **Modelos:**  
  Representan las entidades de datos y definen sus propiedades, validaciones y relaciones. Los modelos en Loopback se utilizan para generar automáticamente endpoints RESTful, facilitando la exposición de operaciones CRUD sin necesidad de configuración adicional.

* **Repositorios:**  
  Actúan como una capa intermedia entre los modelos y las fuentes de datos. Los repositorios gestionan las operaciones de acceso a datos y encapsulan la lógica de integración con bases de datos, servicios externos o APIs. Esto permite modificar la fuente de datos sin afectar la lógica de negocio contenida en los modelos y controladores.

* **Servicios:**
  Proporcionan lógica adicional o integración con servicios externos o internos. Los servicios pueden ser utilizados por los controladores para realizar tareas específicas, como enviar correos electrónicos, interactuar con APIs de terceros o realizar cálculos complejos.

* **Datasources:**
  Configuran las conexiones a las fuentes de datos, como bases de datos SQL o NoSQL. Los datasources definen los parámetros de conexión y permiten a los repositorios interactuar con diferentes fuentes de datos sin necesidad de reescribir la lógica de acceso.

==== Controladores

Los controladores son la puerta de entrada a la lógica de negocio de la aplicación. Cada controlador se asocia a un conjunto de rutas y maneja las solicitudes HTTP correspondientes. Loopback permite definir controladores RESTful que responden a métodos HTTP (GET, POST, PUT, DELETE) y generan automáticamente la documentación Swagger (OpenAPI) para cada endpoint.

Los controladores pueden ser personalizados para manejar la lógica de negocio específica, como validaciones adicionales, transformaciones de datos o integración con otros servicios.
Por ejemplo, un controlador de productos podría tener métodos para listar productos, crear nuevos productos y actualizar o eliminar productos existentes. Cada método se asocia a una ruta específica y puede recibir parámetros de entrada a través de la URL o el cuerpo de la solicitud.

El constructor de un controlador puede inyectar dependencias, como repositorios o servicios, utilizando el decorador `@inject`. Esto permite que los controladores sean modulares y reutilizables, facilitando la separación de responsabilidades y la gestión de la lógica de negocio.

.Un ejemplo de un controlador que inyecta un repositorio y un servicio
[source, typescript]
----
// filepath: /home/rojaldo/cursos/node/curso_loopback/src/controllers/product.controller.ts
import {inject} from '@loopback/core';
import {repository} from '@loopback/repository';
import {get, post, requestBody} from '@loopback/rest';
import {ProductRepository} from '../repositories/product.repository';
import {MyService} from '../services/my.service';

export class ProductController {
  constructor(
    @repository(ProductRepository)
    private productRepository: ProductRepository,
    @inject('services.MyService')
    private myService: MyService,
  ) {}

  // Endpoint GET para obtener la lista de productos
  @get('/products')
  async listProducts(): Promise<object> {
    const products = await this.productRepository.find();
    return { products };
  }

  // Endpoint POST para crear un nuevo producto y utilizar el servicio
  @post('/products')
  async createProduct(
    @requestBody() product: object,
  ): Promise<object> {
    const createdProduct = await this.productRepository.create(product);
    // Procesa lógica adicional con el servicio inyectado
    this.myService.process('Producto creado');
    return createdProduct;
  }
}
----

.Para crear documentación OpenAPI a medida, tenemos la anotación `@api` que permite definir la documentación de cada endpoint. Por ejemplo:
[source, typescript]
----
// filepath: /home/rojaldo/cursos/node/curso_loopback/src/controllers/product.controller.ts
import {inject} from '@loopback/core';
import {repository} from '@loopback/repository';
import {get, post, requestBody, api} from '@loopback/rest';
import {Product} from '../models/product.model';
import {ProductRepository} from '../repositories/product.repository';
import {MyService} from '../services/my.service';

export class ProductController {
  constructor(
    @repository(ProductRepository)
    private productRepository: ProductRepository,
    @inject('services.MyService')
    private myService: MyService,
  ) {}

  @api({
    summary: 'Obtiene la lista de todos los productos',
    responses: {
      '200': {
        description: 'Productos listados exitosamente',
        content: {
          'application/json': {
            schema: {
              type: 'array',
              items: {'x-ts-type': Product},
            },
          },
        },
      },
    },
  })
  @get('/products')
  async listProducts(): Promise<Product[]> {
    return this.productRepository.find();
  }

  @api({
    summary: 'Crea un nuevo producto',
    requestBody: {
      content: {
        'application/json': {
          schema: {'x-ts-type': Product},
        },
      },
    },
    responses: {
      '200': {
        description: 'Producto creado exitosamente',
        content: {
          'application/json': {
            schema: {'x-ts-type': Product},
          },
        },
      },
    },
  })
  @post('/products')
  async createProduct(
    @requestBody() product: Product,
  ): Promise<Product> {
    this.myService.process('Producto creado');
    return this.productRepository.create(product);
  }
}
----

.Un trolador puede recibir parámetros en:
* El cuerpo de la solicitud (request body). Con `@requestBody`.
* Las consultas (query parameters). Con `@param.query`.
* Los parámetros de ruta (path parameters). Con `@param.path`.
* Los encabezados (headers). Con `@param.header`.

.Un ejemplo de controlador que utiliza diferentes tipos de parámetros en Loopback
[source, typescript]
----
// filepath: /home/rojaldo/cursos/node/curso_loopback/src/controllers/example.controller.ts
import {post, get, requestBody, param} from '@loopback/rest';

export class ExampleController {
  @post('/items/{id}')
  async createItem(
    @param.path.number('id') id: number,
    @param.query.string('filter') filter: string,
    @param.header.string('x-custom-header') customHeader: string,
    @requestBody() body: {name: string; description?: string},
  ): Promise<object> {
    // Ejemplo de procesamiento de los parámetros recibidos
    return {
      id,
      filter,
      customHeader,
      body,
    };
  }

  /**
   * Endpoint GET que utiliza un parámetro de ruta para obtener un ítem.
   */
  @get('/items/{id}')
  async getItem(
    @param.path.number('id') id: number,
    @param.query.string('verbose') verbose?: string,
  ): Promise<object> {
    return {
      id,
      verbose,
      message: `Obteniendo el item con id ${id}`,
    };
  }
}
----

Una de las funciones más importantes de los controladores es la gestión de las respuestas HTTP. Loopback permite devolver diferentes tipos de respuestas según el resultado de la operación, como códigos de estado HTTP, mensajes personalizados o datos en formato JSON.

Esto se logra utilizando los métodos `res.status()` y `res.json()`, que permiten establecer el código de estado y el cuerpo de la respuesta, respectivamente.

Para los errores, Loopback proporciona la clase `HttpErrors`, que permite lanzar errores HTTP con códigos de estado específicos y mensajes personalizados. Esto facilita el manejo de errores y la comunicación clara con los clientes de la API.

.Un ejemplo de un método post que devuelve un código de estado 201 y un mensaje personalizado en caso de éxito y un 400 en caso de error con HttpErrors
[source, typescript]
----
// filepath: /home/rojaldo/cursos/node/curso_loopback/src/controllers/status.controller.ts
import {
  post,
  requestBody,
  HttpErrors,
  Response,
  RestBindings,
  inject,
} from '@loopback/rest';

export class StatusController {
  constructor(
    @inject(RestBindings.Http.RESPONSE) private res: Response,
  ) {}

  @post('/create-item')
  async createItem(
    @requestBody() item: {name?: string; [key: string]: any},
  ): Promise<object> {
    try {
      // Validación simple: se requiere el nombre del ítem
      if (!item || !item.name) {
        throw new Error('El nombre del ítem es requerido');
      }
      // Lógica de creación (simulada)
      const createdItem = {id: 1, ...item};

      // Establece el código de estado 201 y retorna el mensaje de éxito
      this.res.status(201);
      return {
        message: 'Ítem creado exitosamente',
        data: createdItem,
      };
    } catch (error) {
      // En caso de error, se lanza un error Http con estado 400 y mensaje personalizado
      throw new HttpErrors.BadRequest(error.message || 'Error al crear el ítem');
    }
  }
}
----


==== Modelos

Los modelos son la representación de las entidades del dominio en Loopback. Definen las propiedades, tipos de datos y validaciones necesarias para cada entidad, así como las relaciones entre diferentes modelos.

Los modelos se generan automáticamente a partir de las definiciones de datos y se utilizan para crear automáticamente los endpoints RESTful correspondientes. Esto permite que los desarrolladores se centren en la lógica de negocio sin preocuparse por la implementación de la API.


.Los modelos en Loopback son altamente configurables y permiten definir propiedades como:
* **Propiedades:** Definición de los atributos del modelo, incluyendo tipos de datos, longitudes y validaciones.
* **Relaciones:** Definición de las relaciones entre diferentes modelos, como uno a uno, uno a muchos o muchos a muchos.
* **Validaciones:** Configuración de reglas de validación para asegurar la integridad de los datos, como campos requeridos, formatos específicos o valores únicos.
* **Métodos personalizados:** Posibilidad de definir métodos adicionales en los modelos para realizar operaciones específicas o cálculos relacionados con la entidad.

.Las anotaciones de relaciones son:
* `@hasMany`: Define una relación uno a muchos, donde un modelo puede tener múltiples instancias de otro modelo.
* `@hasOne`: Define una relación uno a uno, donde un modelo tiene una única instancia de otro modelo.
* `@belongsTo`: Define una relación de pertenencia, donde un modelo pertenece a otro modelo.
* `@hasManyThrough`: Define una relación muchos a muchos a través de un modelo intermedio.
* `@ReferencesMany`: Define una relación de referencia, donde un modelo puede referenciar múltiples instancias de otro modelo.

Por ejemplo, un modelo de producto podría tener propiedades como `id`, `nombre`, `precio` y `categoría`, así como relaciones con otros modelos como `Categoría` o `Proveedor`. Esto permite que los desarrolladores trabajen con objetos de dominio en lugar de lidiar directamente con consultas SQL o comandos específicos de la base de datos.

.Un ejemplo de un modelo de producto en Loopback con propiedades y relaciones
[source, typescript]
----
// filepath: /home/rojaldo/cursos/node/curso_loopback/src/models/product.model.ts
import {Entity, model, property, belongsTo} from '@loopback/repository';
import {Category} from './category.model';
import {Provider} from './provider.model';

@model({
  settings: {},
})
export class Product extends Entity {
  @property({
    type: 'number',
    id: true,
    generated: true,
  })
  id?: number;

  @property({
    type: 'string',
    required: true,
  })
  nombre: string;

  @property({
    type: 'number',
    required: true,
  })
  precio: number;

  // Relación: Un producto pertenece a una categoría
  @belongsTo(() => Category)
  categoriaId: number;

  // Relación: Un producto es suministrado por un proveedor
  @belongsTo(() => Provider)
  proveedorId: number;

  constructor(data?: Partial<Product>) {
    super(data);
  }
}
----

==== Repositorios

Los repositorios son componentes clave en Loopback que facilitan la interacción con las fuentes de datos. Actúan como una capa de abstracción entre los modelos y las bases de datos, permitiendo realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) de manera sencilla y eficiente.

Los repositorios se generan automáticamente a partir de los modelos y se configuran para conectarse a las fuentes de datos definidas en el proyecto. Esto permite que los desarrolladores trabajen con objetos de dominio en lugar de lidiar directamente con consultas SQL o comandos específicos de la base de datos.

Los repositorios pueden incluir métodos personalizados para realizar consultas específicas o manipular datos de manera más compleja. Además, Loopback proporciona una serie de métodos predefinidos para realizar operaciones comunes, como `find()`, `create()`, `update()`, y `delete()`.
Por ejemplo, un repositorio de productos podría tener métodos para buscar productos por nombre, actualizar el precio de un producto o eliminar un producto específico. Estos métodos pueden ser utilizados directamente en los controladores o en otros componentes de la aplicación.

.Un ejemplo de un repositorio que extiende el repositorio base de Loopback
[source, typescript]
----
import {inject} from '@loopback/core';
import {DefaultCrudRepository} from '@loopback/repository';
import {DbDataSource} from '../datasources';
import {Todo, TodoRelations} from '../models';

export class TodoRepository extends DefaultCrudRepository<
  Todo,
  typeof Todo.prototype.id,
  TodoRelations
> {
  constructor(@inject('datasources.db') dataSource: DbDataSource) {
    super(Todo, dataSource);
  }
}
----


==== Servicios

Los servicios en Loopback son componentes que encapsulan la lógica de negocio y permiten la reutilización de código en diferentes partes de la aplicación. Los servicios pueden ser utilizados por los controladores, repositorios u otros servicios, facilitando la separación de responsabilidades y la modularidad del código.

Los servicios pueden incluir lógica de negocio compleja, integración con APIs externas, procesamiento de datos o cualquier otra funcionalidad que no encaje directamente en los modelos o controladores. Esto permite que los desarrolladores mantengan el código limpio y organizado, evitando la duplicación de lógica en diferentes partes de la aplicación.

.Un ejemplo de un servicio que realiza una operación específica en Loopback
[source, typescript]
----
export class MyService {
  constructor() {
    // Inicialización del servicio si es necesario
  }

  process(input: string): string {
    // Ejemplo de lógica: convertir el texto a mayúsculas y agregar un prefijo.
    return `Resultado procesado: ${input.toUpperCase()}`;
  }
}
----

.Un ejemplo de inyección de un servicio en un controlador utilizando el decorador @inject
[source, typescript]
----
// filepath: /home/rojaldo/cursos/node/curso_loopback/src/controllers/order.controller.ts
import {inject} from '@loopback/core';
import {get} from '@loopback/rest';
import {MyService} from '../services/my.service';

export class OrderController {
  constructor(
    @inject('services.MyService')
    private myService: MyService,
  ) {}

  // Endpoint GET que utiliza el servicio inyectado para procesar una orden
  @get('/order/process')
  processOrder(): object {
    const result = this.myService.process('Orden procesada');
    return {message: result};
  }
}
----

==== Datasources

Los datasources son componentes que configuran la conexión a las fuentes de datos, como bases de datos SQL o NoSQL. En Loopback, los datasources permiten a los repositorios interactuar con diferentes fuentes de datos sin necesidad de reescribir la lógica de acceso.

Los datasources se definen en archivos de configuración y pueden incluir detalles como el tipo de conector (por ejemplo, MySQL, MongoDB), la URL de conexión, las credenciales y otros parámetros necesarios para establecer la conexión.

Los datasources pueden ser utilizados por los repositorios para realizar operaciones CRUD y consultas a las bases de datos. Esto permite que los desarrolladores trabajen con objetos de dominio en lugar de lidiar directamente con consultas SQL o comandos específicos de la base de datos.

.Un ejemplo de un datasource configurado para una base de datos MySQL
[source, typescript]
----
import {juggler} from '@loopback/repository';
import {inject} from '@loopback/core';

const config = {
  name: 'mysqlDs',
  connector: 'mysql',
  host: 'localhost',
  port: 3306,
  user: 'tuUsuario',
  password: 'tuContraseña',
  database: 'nombreDeLaBaseDeDatos'
};

export class MysqlDataSource extends juggler.DataSource {
  static dataSourceName = 'mysqlDs';

  constructor(
    @inject('datasources.config.mysqlDs', {optional: true})
    dsConfig: object = config,
  ) {
    super(dsConfig);
  }
}
----

=== Conexión e integración con bases de datos
Loopback simplifica la integración con diversas bases de datos y otras fuentes de información mediante el uso de adaptadores (connectors). Entre las características principales se encuentran:

* **Adaptadores de Datos:**  
  Loopback soporta múltiples conectores para bases de datos SQL (como MySQL, PostgreSQL) y NoSQL (como MongoDB). Esto permite a los desarrolladores trabajar con el motor de base de datos que mejor se adapte a las necesidades del proyecto.

* **Configuración y Conexión:**  
  Las conexiones a bases de datos se configuran en el directorio **datasources/**. Cada fuente de datos se define en un archivo con la configuración necesaria (credenciales, URL, parámetros de conexión), lo que permite conectar la aplicación con la base de datos sin alterar el código central de la aplicación.

* **Migraciones y Sincronización de Modelos:**  
  Loopback ofrece herramientas para la migración y sincronización de modelos con las estructuras de las bases de datos, facilitando la gestión evolutiva del esquema de datos. Esto es particularmente útil en entornos ágiles donde los requisitos pueden cambiar con el tiempo.

Esta separación de la configuración de la base de datos y la lógica de negocio garantiza que la aplicación pueda adaptarse rápidamente a nuevos requisitos y que la integración con fuentes externas sea sencilla y mantenible.

== 4. Desarrollo de APIs RESTful

=== Definición de modelos y relaciones
En Loopback, los modelos representan las entidades del dominio y se definen mediante archivos de configuración (generalmente en JSON o TypeScript). Cada modelo especifica las propiedades, validaciones y relaciones con otros modelos. Las relaciones pueden ser de uno a muchos, muchos a uno o muchos a muchos, permitiendo estructurar de forma coherente la lógica y las conexiones entre entidades.

Ejemplo básico de un modelo:
[source, javascript]
----
{
  "name": "Product",
  "properties": {
    "id": {
      "type": "number",
      "id": true,
      "generated": true
    },
    "name": {
      "type": "string",
      "required": true
    },
    "price": {
      "type": "number",
      "required": true
    }
  },
  "relations": {
    "category": {
      "type": "belongsTo",
      "model": "Category"
    }
  }
}
----

=== Configuración de endpoints y rutas
Loopback genera automáticamente endpoints RESTful a partir de los modelos definidos, facilitando la exposición inmediata de operaciones CRUD. No obstante, es común personalizar o añadir rutas específicas para satisfacer requisitos particulares.

Para ello, se definen controladores que gestionan la lógica del negocio. Cada método del controlador se asocia a una ruta concreta mediante decoradores o configuraciones en el archivo de rutas. Por ejemplo:

[source, javascript]
----
import {get, post, requestBody} from '@loopback/rest';

export class ProductController {
  @get('/products')
  async listProducts() {
    // Lógica para obtener la lista de productos
  }

  @post('/products')
  async createProduct(@requestBody() product: object) {
    // Lógica para crear un nuevo producto
  }
}
----

=== Validaciones y manejo de errores en las APIs
Loopback integra validaciones a nivel de modelo para asegurar la integridad de los datos. Estas validaciones, como campos requeridos o patrones de formato, se configuran directamente en la definición del modelo.

Además, el framework implementa un manejo centralizado de errores a través de interceptores y middleware. Esto permite capturar errores en cualquier parte de la cadena de procesamiento y devolver respuestas consistentes al cliente. Por ejemplo, se puede definir un interceptor para registrar y formatear los errores antes de enviarlos como respuesta:
  
[source, javascript]
----
import {Interceptor, InvocationContext, InvocationResult, Provider} from '@loopback/context';
import {HttpErrors} from '@loopback/rest';

export class ErrorInterceptor implements Interceptor {
  async intercept(ctx: InvocationContext, next: () => Promise<InvocationResult>): Promise<InvocationResult> {
    try {
      return await next();
    } catch (err) {
      // Lógica para manejar y formatear el error
      throw new HttpErrors.InternalServerError('Ocurrió un error en la API');
    }
  }
}
----

Con estas estrategias, Loopback garantiza que las APIs sean robustas, seguras y fáciles de mantener.

== 5. Integración con Bases de Datos

Esta sección abarca la conexión de la aplicación Loopback con diversas bases de datos utilizando adaptadores, la sincronización de modelos con la base de datos y ejemplos prácticos para afianzar los conceptos.

=== Configuración de adaptadores para MySQL, PostgreSQL y MongoDB
Loopback soporta distintos conectores para acceder a bases de datos SQL y NoSQL. Para configurar cada uno, se debe crear un archivo en el directorio **datasources/** que contenga los parámetros de conexión. Por ejemplo:

[source, javascript]
----
/* Ejemplo para MySQL */
{
  "name": "mysqlDs",
  "connector": "mysql",
  "host": "localhost",
  "port": 3306,
  "user": "tuUsuario",
  "password": "tuContraseña",
  "database": "nombreDeLaBaseDeDatos"
}
----

[source, javascript]
----
/* Ejemplo para PostgreSQL */
{
  "name": "postgresDs",
  "connector": "postgresql",
  "host": "localhost",
  "port": 5432,
  "user": "tuUsuario",
  "password": "tuContraseña",
  "database": "nombreDeLaBaseDeDatos"
}
----

[source, javascript]
----
/* Ejemplo para MongoDB */
{
  "name": "mongoDs",
  "connector": "mongodb",
  "url": "mongodb://localhost:27017/nombreDeLaBaseDeDatos"
}
----

Cada archivo define el adaptador a usar y las credenciales necesarias para la conexión.

=== Migraciones y sincronización de modelos
Loopback ofrece métodos para mantener sincronizados los modelos definidos en la aplicación con los esquemas de la base de datos:
  
* **Automigrate:** Elimina y vuelve a crear las tablas basándose en el modelo definido; útil en entornos de desarrollo.
* **Autoupdate:** Actualiza la estructura de la base de datos sin eliminar los datos existentes; ideal para entornos de producción.

Se pueden invocar estos métodos en el archivo de inicio de la aplicación o a través de scripts personalizados. Por ejemplo:
  
[source, javascript]
----
async function migrateSchema(app) {
  const ds = app.datasources.mysqlDs;
  await ds.automigrate(); // O bien: await ds.autoupdate();
  console.log('Migración completada');
}
----
  
De esta forma, se garantiza que los cambios en los modelos se reflejen en la base de datos de forma controlada.

==== Inyección del objeto response

En Loopback es posible inyectar el objeto response en un controlador para poder manipular directamente la respuesta HTTP. Con el decorador @inject y el binding RestBindings.Http.RESPONSE se puede acceder a este objeto de forma sencilla. A continuación, se muestra un ejemplo:

[source, typescript]
----
import {Response, RestBindings} from '@loopback/rest';
import {inject} from '@loopback/core';

export class PingController {
  constructor(@inject(RestBindings.Http.RESPONSE) private response: Response) {}

  @get('/ping')
  ping(): Response {
    // Access the response object via `this.response`
    this.response.status(200).send({
      greeting: 'Hello from LoopBack',
      date: new Date(),
    });
    // Return the HTTP response object so that LoopBack framework skips the
    // generation of HTTP response
    return this.response;
  }

  @get('/header')
  header(): string {
    // Set custom http response header
    this.response.set('x-custom-res-header', 'xyz');
    return 'Hello';
  }
}

----

==== Uso del objeto context para acceder a request y response

En LoopBack se puede acceder al objeto context para obtener instancias de la solicitud y respuesta HTTP a través de inyección de dependencias. Esto permite realizar operaciones como extraer información de la solicitud (por ejemplo, la IP del cliente) o modificar la respuesta (por ejemplo, agregando encabezados personalizados). A continuación se muestra un ejemplo de cómo hacerlo en un controlador:

[source, typescript]
----
import {RequestContext, RestBindings} from '@loopback/rest';
import {inject} from '@loopback/core';

export class PingController {
  constructor(
    @inject(RestBindings.Http.CONTEXT) private requestCtx: RequestContext,
  ) {}

  ping(): Response {
    const {request, response} = this.requestCtx;
    this.response.status(200).send({
      greeting: 'Hello from LoopBack',
      date: new Date(),
      url: this.req.url,
      headers: Object.assign({}, this.req.headers),
    });
    // Return the HTTP response object so that LoopBack framework skips the
    // generation of HTTP response
    return response;
  }
}
----

==== Uso de Middleware para acceder a request y response

En Loopback puedes definir middlewares para interceptar y manipular la solicitud (request) y la respuesta (response) en el ciclo de vida de la petición. Esto es útil para tareas como logging, autenticación, o modificación de cabeceras.

Un ejemplo de middleware que accede a ambos objetos es el siguiente:

[source, typescript]
----
import {Middleware, MiddlewareContext} from '@loopback/rest';
import {debugFactory} from 'debug';
import {v1} from 'uuid';
const trace = debugFactory('trace:request-response');

/**
 * An middleware for tracing HTTP requests/responses
 * @param ctx - Context object
 * @param next - Downstream middleware/handlers
 */
export const tracingMiddleware: Middleware = async (ctx, next) => {
  setupRequestId(ctx);
  const {request, response} = ctx;
  try {
    if (trace.enabled) {
      const reqObj = {
        method: request.method,
        originalUrl: request.originalUrl,
        headers: request.headers,
        // Body is not available yet before `parseParams`
      };
      trace('Request: %s', reqObj);
    }
    const result = await next();
    if (trace.enabled) {
      const resObj = {
        statusCode: response.statusCode,
        headers: response.getHeaders(),
      };
      trace('Response: %s', resObj);
    }
    return result;
  } catch (err) {
    if (trace.enabled) {
      trace('Error: %s', err);
    }
    throw err;
  }
};

function setupRequestId(ctx: MiddlewareContext) {
  let requestId = ctx.request?.get('X-Request-ID');
  debug(
    'RequestID for %s %s: %s',
    ctx.request.method,
    ctx.request.originalUrl,
    requestId,
  );
  if (requestId == null) {
    requestId = v1();
    debug(
      'A new RequestID is generated for %s %s: %s',
      ctx.request.method,
      ctx.request.originalUrl,
      requestId,
    );
  }

  // Bind `request.id` so that it is available for injection in downstream
  // controllers/services
  ctx.bind('request.id').to(requestId);
}
----

Para utilizar este middleware, regístralo en el arreglo de middlewares de tu aplicación Loopback, normalmente en el archivo de configuración o en el constructor de la aplicación.

=== Ejemplos prácticos
Para consolidar los conceptos, se recomienda realizar ejercicios prácticos tales como:
  
* **Conexión y operación CRUD:**  
  Configura una datasource (por ejemplo, MySQL), define un modelo (como "Product"), y prueba operaciones de creación, lectura, actualización y eliminación utilizando los endpoints generados automáticamente por Loopback.

* **Migración de esquemas:**  
  Modifica el modelo "Product" (agregando nuevos campos) y utiliza el método de migración para actualizar la estructura de la base de datos sin perder datos existentes.

* **Integración con múltiples bases de datos:**  
  Configura dos datasources (por ejemplo, PostgreSQL para datos transaccionales y MongoDB para registros de logs) y muestra cómo separar las operaciones de acceso a datos según la necesidad del proyecto.
  
Estos ejemplos prácticos facilitan el entendimiento de la integración de Loopback con diversos motores de base de datos, permitiendo adaptar la solución a diferentes requerimientos y escenarios.

== 6. Autenticación y Autorización

=== Implementación de estrategias de autenticación
Loopback permite integrar diversas estrategias de autenticación para validar la identidad de los usuarios. Esto puede incluir:
* Autenticación basada en sesiones y certificados.
* Uso de API keys para acceso restringido.
* Integración con proveedores externos (por ejemplo, LDAP o redes sociales).

La configuración se realiza mediante componentes que encapsulan la lógica de cada estrategia, permitiendo sustituir o combinar métodos según los requisitos del proyecto.

=== Uso de OAuth2 y JWT tokens
Para gestionar autorizaciones de manera segura y escalable, se recomienda:
* **OAuth2:** Establece un flujo seguro para que aplicaciones de terceros accedan a recursos protegidos. Configura proveedores de OAuth2 y define scopes de acceso.
* **JWT Tokens:** Se generan al autenticar a un usuario y se incluyen en las solicitudes subsiguientes para verificar la identidad y permisos. La validación del token se realiza en cada endpoint protegido, garantizando que sólo usuarios autorizados puedan acceder a determinados recursos.

La combinación de OAuth2 y JWT proporciona una solución robusta para la autenticación, permitiendo la delegación de credenciales y la administración simplificada de sesiones.

=== Gestión de roles y permisos
La autorización en Loopback se puede gestionar mediante la asignación de roles a los usuarios y la definición de permisos específicos para cada rol. Algunas prácticas incluyen:
* **Asignación de Roles:** Definir roles como administrador, usuario y invitado, y asignarlos durante la autenticación o en el proceso de registro.
* **Control de Acceso:** Implementar middleware o interceptores que verifiquen si el rol del usuario tiene permisos para ejecutar la acción solicitada.
* **Políticas de Seguridad:** Configurar restricciones a nivel de endpoint, modelo o método, permitiendo adaptar la autorización a los requerimientos de la aplicación.

Estas estrategias permiten crear una arquitectura segura y flexible para gestionar tanto la autenticación como la autorización en tus APIs.

== 7. Buenas Prácticas y Optimización

=== Manejo de errores y logging
Para garantizar la fiabilidad y mantenibilidad de la aplicación, es fundamental implementar un manejo de errores consistente y un sistema de logging robusto. Algunas recomendaciones incluyen:
* Uso de interceptores o middleware para capturar y formatear errores de forma centralizada.
* Registro de errores en archivos o sistemas de monitoreo para facilitar la depuración.
* Configuración de niveles de logging (debug, info, warn, error) acorde al entorno (desarrollo o producción).

Ejemplo de un interceptor para manejo de errores:
[source, javascript]
----
import {Interceptor, InvocationContext, InvocationResult} from '@loopback/context';
import {HttpErrors} from '@loopback/rest';

export class ErrorInterceptor implements Interceptor {
  async intercept(ctx: InvocationContext, next: () => Promise<InvocationResult>): Promise<InvocationResult> {
    try {
      return await next();
    } catch (err) {
      console.error('Error en la API:', err);
      throw new HttpErrors.InternalServerError('Error interno del servidor');
    }
  }
}
----

=== Optimización del rendimiento
Para mejorar el rendimiento de la aplicación se pueden aplicar diversas estrategias:
* Optimización de consultas a la base de datos mediante índices y consultas eficientes.
* Implementación de caching para respuestas frecuentes en endpoints críticos.
* Uso de procesos asíncronos y manejo adecuado de recursos para evitar bloqueos.
* Monitoreo y profiling de la aplicación para identificar y corregir cuellos de botella.

Estas técnicas ayudan a mantener tiempos de respuesta aceptables y a escalar la aplicación de manera eficiente.

=== Pruebas unitarias e integración continua
La calidad del código se garantiza mediante un robusto conjunto de pruebas:
* Pruebas unitarias: Se encargan de validar la funcionalidad aislada de cada componente (modelos, controladores, repositorios).
* Pruebas de integración: Verifican la correcta interacción entre componentes y el acceso a recursos externos.
* Integración continua (CI): Automatiza la ejecución de pruebas con cada cambio en el código, detectando errores de forma temprana y asegurando un despliegue confiable.

Ejemplo básico utilizando Mocha y Chai:
[source, javascript]
----
const {expect} = require('chai');
const {Calculator} = require('../src/calculator');

describe('Calculator', () => {
  it('should correctly add two numbers', () => {
    const calc = new Calculator();
    expect(calc.add(2, 3)).to.equal(5);
  });
});
----

Implementar estas prácticas contribuye a la creación de aplicaciones robustas, seguras y fáciles de mantener.
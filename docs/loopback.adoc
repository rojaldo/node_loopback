:source-highlighter: highlight.js
= Loopback
:icons: font
:toc: left
:toclevels: 2

== 1. Introducción a Loopback

=== ¿Qué es Loopback?
Loopback es un framework de Node.js diseñado para construir APIs RESTful de forma rápida y eficiente. Se basa en una arquitectura modular que permite la integración de múltiples fuentes de datos y facilita tareas comunes en el desarrollo backend, como validaciones, autenticación, y manejo de errores.

=== Historia y Evolución del Framework
Loopback inició como un proyecto de IBM para simplificar el desarrollo de backends para aplicaciones móviles y web. Con el tiempo, ha evolucionado incorporando mejoras tecnológicas y nuevas funcionalidades, convirtiéndose en una herramienta robusta y versátil que se adapta a las necesidades del desarrollo ágil y la integración de servicios modernos.

=== Ventajas y Casos de Uso
Loopback presenta varias ventajas:
* **Generación Automática de APIs:** Permite definir modelos de datos que se transforman automáticamente en endpoints RESTful.
* **Flexibilidad en la Conexión de Datos:** Facilita la integración con bases de datos SQL y NoSQL, así como con servicios externos.
* **Seguridad Integrada:** Ofrece mecanismos para autenticación y autorización de manera nativa.
* **Comunidad y Soporte:** Cuenta con una comunidad activa y extensa documentación, lo que facilita la resolución de problemas y la implementación de casos complejos.

*Casos de Uso Comunes:*
* Desarrollo de microservicios.
* Creación de backends para aplicaciones móviles y web.
* Integración de múltiples fuentes de datos en entornos empresariales.
* Proyectos que requieren escalabilidad y una rápida generación de APIs.

== 2. Instalación y Configuración Inicial

=== Requisitos previos: Node.js y npm
.Antes de comenzar, asegúrate de tener instalados Node.js y npm (Node Package Manager). Puedes verificar su instalación ejecutando los siguientes comandos en la terminal:
[source, shell]
----
node --version
npm --version
----
Si no están instalados, descárgalos e instálalos desde [https://nodejs.org](https://nodejs.org).

=== Instalación del Loopback CLI
.Loopback CLI es una herramienta de línea de comandos que facilita la creación y gestión de proyectos Loopback. Para instalarlo globalmente, ejecuta:
[source, shell]
----
npm install -g @loopback/cli
----
.Verifica la instalación con:
[source, shell]
----
lb4 --help
----

=== Creación y configuración de un proyecto Loopback
Una vez instalado el CLI, crea un nuevo proyecto Loopback siguiendo estos pasos:

.Ejecuta el comando: 
[source, shell]
----
   lb4 app
----

.Introduce el nombre del proyecto y responde a las preguntas de configuración (tipo de aplicación, integración con bases de datos, etc.)
[source, shell]
----
Project name: getting-started
? Project description: Getting started tutorial
? Project root directory: getting-started
? Application class name: StarterApplication
? Select features to enable in the project:
❯◉ Enable eslint: add a linter with pre-configured lint rules
 ◉ Enable prettier: install prettier to format code conforming to rules
 ◉ Enable mocha: install mocha to run tests
 ◉ Enable loopbackBuild: use @loopback/build helpers (e.g. lb-eslint)
 ◉ Enable editorconfig: add EditorConfig files
 ◉ Enable vscode: add VSCode config files
 ◉ Enable docker: include Dockerfile and .dockerignore
 ◉ Enable repositories: include repository imports and RepositoryMixin
 ◉ Enable services: include service-proxy imports and ServiceMixin
----

Al terminar, se habrá generado la estructura básica del proyecto, incluyendo carpetas para modelos, controladores y repositorios.

.Revisa el archivo `package.json` y utiliza el comando:
[source, shell]
----
npm start
----
para iniciar el servidor y verificar que el entorno esté configurado correctamente.

=== Creación de un Controller

.Para crear un controlador básico, utiliza el comando:
[source, shell]
----
lb4 controller
----

.Introduce el nombre del controlador y selecciona el tipo de controlador (REST, GraphQL, etc.). Por ejemplo:
[source, shell]
----
? Controller class name: hello
? What kind of controller would you like to generate? Empty Controller
  create src/controllers/hello.controller.ts
  update src/controllers/index.ts

Controller hello was now created in src/controllers/
----

.En el archivo generado, define un método simple que responda a una solicitud GET:
[source, javascript]
----
import {get} from '@loopback/rest';

export class HelloController {
  @get('/hello')
  hello(): string {
    return 'Hello world!';
  }
}
----

Prueba el endpoint accediendo a `http://localhost:3000/hello` en tu navegador o utilizando herramientas como Postman.

=== Creación de un servicio

Para crear un servicio en Loopback, utiliza el CLI de Loopback y ejecuta el siguiente comando:

[source, shell]
----
lb4 service [opciones] [nombre del servicio]
----

A continuación, se te indicará configurar el servicio mediante una serie de preguntas, como:
* Nombre del servicio.
* Tipo de servicio (por ejemplo, servicio personalizado para lógica de negocio o integración con APIs externas).
* Ruta de ubicación del archivo generado.

.Las opciones pueden incluir:
* `--type`: Especifica el tipo de servicio (por ejemplo, `custom`, `external`).
* `--datasource`: Indica la fuente de datos a la que se conectará el servicio, que se sepecifica en src/datasources.

.Hay 3 tipos de servicios que puedes crear:
* `proxy`: Para crear un servicio proxy que se conecte a un servicio externo remoto REST, SOAP, gRPC, etc. Tiene que haber un datasource configurado en src/datasources.
* `class`: Para crear un servicio de clase que encapsule la lógica de negocio.
* `provider`: Para crear un servicio que proporcione datos o lógica a otros componentes de la aplicación.

Una vez completado, se creará un archivo en el directorio `src/services/`, que contendrá la estructura básica del servicio. Por ejemplo, si creas un servicio llamado `MyService`, el archivo generado podría tener el siguiente contenido:

[source, ts]
----
export class MyService {
  constructor() {
    // Inicialización del servicio
  }

  /**
   * Método que implementa la lógica del servicio.
   * @param input Entrada para procesar
   * @returns Resultado procesado
   */
  process(input: string): string {
    // Lógica del servicio
    return `Resultado: ${input}`;
  }
}
----

Este servicio se puede inyectar en controladores u otros componentes mediante el sistema de inyección de dependencias de Loopback. Por ejemplo, para usar el servicio en un controlador, puedes hacerlo de la siguiente manera:

[source, ts]
----
import {inject} from '@loopback/core';
import {MyService} from '../services';

export class MyController {
  constructor(
    @inject('services.MyService') // Asegúrate de registrar el servicio
    private myService: MyService,
  ) {}

  // Ejemplo de endpoint que utiliza el servicio
  async ejemploEndpoint(): Promise<string> {
    const resultado = this.myService.process('Entrada de ejemplo');
    return resultado;
  }
}
----

Con estos pasos, habrás creado e integrado correctamente un servicio en tu aplicación Loopback, lo que te permitirá encapsular y reutilizar lógica de negocio de forma modular y eficiente.

=== Creación de un datasource

Un datasource en Loopback es una configuración que define cómo se conecta la aplicación a una fuente de datos, como una base de datos SQL o NoSQL. Para crear un datasource.
.Para usar el CLI de Loopback y ejecuta el siguiente comando:
[source, shell]
----
lb4 datasource [options] [<name>]
----

.Las opciones pueden incluir:
* `--connector`: Especifica el conector a utilizar (por ejemplo, `mysql`, `mongodb`, `postgresql`, etc.).
* `--config`: Permite especificar un archivo de configuración para el datasource.
* `--skip-cache`: Evita que se genere un archivo de caché para el datasource.
* `--skip-install`: Evita la instalación de dependencias adicionales.
* `--format`: Permite especificar el formato del código generado.
* `--yes`: Acepta todas las opciones por defecto sin preguntar.
* `--help`: Muestra la ayuda del comando.



== 3. Arquitectura de Loopback

La arquitectura de Loopback está pensada para aportar una estructura organizada y escalable, facilitando la separación de responsabilidades y la integración con diversas fuentes de datos.

=== Estructura de un proyecto Loopback
Un proyecto Loopback típico se organiza en una serie de carpetas que ayudan a mantener el código modularizado y fácil de mantener. Algunas de las carpetas y archivos principales son:

* **src/**: Contiene el código fuente de la aplicación.
  * **models/**: Define los modelos de datos que representan las entidades del dominio.
  * **controllers/**: Gestiona la lógica de negocio y responde a las solicitudes HTTP.
  * **repositories/**: Encapsula la lógica de acceso y manipulación de datos, facilitando la conexión con bases de datos u otros servicios.
  * **datasources/**: Configura las conexiones a las bases de datos y otros proveedores de datos.
  * **routes/** (opcional): Define rutas y mapea endpoints a controladores, en caso de querer una organización adicional.
* **package.json**: Archivo de configuración de Node.js, que incluye dependencias y scripts de arranque.
* **.env**: Archivo opcional para definir variables de entorno que configuran aspectos del entorno de ejecución (por ejemplo, detalles de conexión a bases de datos).

Esta estructura permite que cada componente de la aplicación tenga un rol definido y se integre de forma coherente en el conjunto del proyecto.

=== Componentes principales: Modelos, Controladores y Repositorios
El diseño modular de Loopback se basa en tres componentes esenciales:

* **Modelos:**  
  Representan las entidades de datos y definen sus propiedades, validaciones y relaciones. Los modelos en Loopback se utilizan para generar automáticamente endpoints RESTful, facilitando la exposición de operaciones CRUD sin necesidad de configuración adicional.

* **Controladores:**  
  Encargados de manejar las solicitudes HTTP, los controladores contienen la lógica de negocio de la aplicación. Se comunican con los repositorios para recuperar o modificar datos y devuelven respuestas adecuadas a los clientes.

* **Repositorios:**  
  Actúan como una capa intermedia entre los modelos y las fuentes de datos. Los repositorios gestionan las operaciones de acceso a datos y encapsulan la lógica de integración con bases de datos, servicios externos o APIs. Esto permite modificar la fuente de datos sin afectar la lógica de negocio contenida en los modelos y controladores.

Estos componentes trabajan en conjunto para mantener el código organizado, facilitar el desarrollo y promover la reutilización de código a lo largo del proyecto.

=== Conexión e integración con bases de datos
Loopback simplifica la integración con diversas bases de datos y otras fuentes de información mediante el uso de adaptadores (connectors). Entre las características principales se encuentran:

* **Adaptadores de Datos:**  
  Loopback soporta múltiples conectores para bases de datos SQL (como MySQL, PostgreSQL) y NoSQL (como MongoDB). Esto permite a los desarrolladores trabajar con el motor de base de datos que mejor se adapte a las necesidades del proyecto.

* **Configuración y Conexión:**  
  Las conexiones a bases de datos se configuran en el directorio **datasources/**. Cada fuente de datos se define en un archivo con la configuración necesaria (credenciales, URL, parámetros de conexión), lo que permite conectar la aplicación con la base de datos sin alterar el código central de la aplicación.

* **Migraciones y Sincronización de Modelos:**  
  Loopback ofrece herramientas para la migración y sincronización de modelos con las estructuras de las bases de datos, facilitando la gestión evolutiva del esquema de datos. Esto es particularmente útil en entornos ágiles donde los requisitos pueden cambiar con el tiempo.

Esta separación de la configuración de la base de datos y la lógica de negocio garantiza que la aplicación pueda adaptarse rápidamente a nuevos requisitos y que la integración con fuentes externas sea sencilla y mantenible.

== 4. Desarrollo de APIs RESTful

=== Definición de modelos y relaciones
En Loopback, los modelos representan las entidades del dominio y se definen mediante archivos de configuración (generalmente en JSON o TypeScript). Cada modelo especifica las propiedades, validaciones y relaciones con otros modelos. Las relaciones pueden ser de uno a muchos, muchos a uno o muchos a muchos, permitiendo estructurar de forma coherente la lógica y las conexiones entre entidades.

Ejemplo básico de un modelo:
[source, javascript]
----
{
  "name": "Product",
  "properties": {
    "id": {
      "type": "number",
      "id": true,
      "generated": true
    },
    "name": {
      "type": "string",
      "required": true
    },
    "price": {
      "type": "number",
      "required": true
    }
  },
  "relations": {
    "category": {
      "type": "belongsTo",
      "model": "Category"
    }
  }
}
----

=== Configuración de endpoints y rutas
Loopback genera automáticamente endpoints RESTful a partir de los modelos definidos, facilitando la exposición inmediata de operaciones CRUD. No obstante, es común personalizar o añadir rutas específicas para satisfacer requisitos particulares.

Para ello, se definen controladores que gestionan la lógica del negocio. Cada método del controlador se asocia a una ruta concreta mediante decoradores o configuraciones en el archivo de rutas. Por ejemplo:

[source, javascript]
----
import {get, post, requestBody} from '@loopback/rest';

export class ProductController {
  @get('/products')
  async listProducts() {
    // Lógica para obtener la lista de productos
  }

  @post('/products')
  async createProduct(@requestBody() product: object) {
    // Lógica para crear un nuevo producto
  }
}
----

=== Validaciones y manejo de errores en las APIs
Loopback integra validaciones a nivel de modelo para asegurar la integridad de los datos. Estas validaciones, como campos requeridos o patrones de formato, se configuran directamente en la definición del modelo.

Además, el framework implementa un manejo centralizado de errores a través de interceptores y middleware. Esto permite capturar errores en cualquier parte de la cadena de procesamiento y devolver respuestas consistentes al cliente. Por ejemplo, se puede definir un interceptor para registrar y formatear los errores antes de enviarlos como respuesta:
  
[source, javascript]
----
import {Interceptor, InvocationContext, InvocationResult, Provider} from '@loopback/context';
import {HttpErrors} from '@loopback/rest';

export class ErrorInterceptor implements Interceptor {
  async intercept(ctx: InvocationContext, next: () => Promise<InvocationResult>): Promise<InvocationResult> {
    try {
      return await next();
    } catch (err) {
      // Lógica para manejar y formatear el error
      throw new HttpErrors.InternalServerError('Ocurrió un error en la API');
    }
  }
}
----

Con estas estrategias, Loopback garantiza que las APIs sean robustas, seguras y fáciles de mantener.

== 5. Integración con Bases de Datos

Esta sección abarca la conexión de la aplicación Loopback con diversas bases de datos utilizando adaptadores, la sincronización de modelos con la base de datos y ejemplos prácticos para afianzar los conceptos.

=== Configuración de adaptadores para MySQL, PostgreSQL y MongoDB
Loopback soporta distintos conectores para acceder a bases de datos SQL y NoSQL. Para configurar cada uno, se debe crear un archivo en el directorio **datasources/** que contenga los parámetros de conexión. Por ejemplo:

[source, javascript]
----
/* Ejemplo para MySQL */
{
  "name": "mysqlDs",
  "connector": "mysql",
  "host": "localhost",
  "port": 3306,
  "user": "tuUsuario",
  "password": "tuContraseña",
  "database": "nombreDeLaBaseDeDatos"
}
----

[source, javascript]
----
/* Ejemplo para PostgreSQL */
{
  "name": "postgresDs",
  "connector": "postgresql",
  "host": "localhost",
  "port": 5432,
  "user": "tuUsuario",
  "password": "tuContraseña",
  "database": "nombreDeLaBaseDeDatos"
}
----

[source, javascript]
----
/* Ejemplo para MongoDB */
{
  "name": "mongoDs",
  "connector": "mongodb",
  "url": "mongodb://localhost:27017/nombreDeLaBaseDeDatos"
}
----

Cada archivo define el adaptador a usar y las credenciales necesarias para la conexión.

=== Migraciones y sincronización de modelos
Loopback ofrece métodos para mantener sincronizados los modelos definidos en la aplicación con los esquemas de la base de datos:
  
* **Automigrate:** Elimina y vuelve a crear las tablas basándose en el modelo definido; útil en entornos de desarrollo.
* **Autoupdate:** Actualiza la estructura de la base de datos sin eliminar los datos existentes; ideal para entornos de producción.

Se pueden invocar estos métodos en el archivo de inicio de la aplicación o a través de scripts personalizados. Por ejemplo:
  
[source, javascript]
----
async function migrateSchema(app) {
  const ds = app.datasources.mysqlDs;
  await ds.automigrate(); // O bien: await ds.autoupdate();
  console.log('Migración completada');
}
----
  
De esta forma, se garantiza que los cambios en los modelos se reflejen en la base de datos de forma controlada.

=== Ejemplos prácticos
Para consolidar los conceptos, se recomienda realizar ejercicios prácticos tales como:
  
* **Conexión y operación CRUD:**  
  Configura una datasource (por ejemplo, MySQL), define un modelo (como "Product"), y prueba operaciones de creación, lectura, actualización y eliminación utilizando los endpoints generados automáticamente por Loopback.

* **Migración de esquemas:**  
  Modifica el modelo "Product" (agregando nuevos campos) y utiliza el método de migración para actualizar la estructura de la base de datos sin perder datos existentes.

* **Integración con múltiples bases de datos:**  
  Configura dos datasources (por ejemplo, PostgreSQL para datos transaccionales y MongoDB para registros de logs) y muestra cómo separar las operaciones de acceso a datos según la necesidad del proyecto.
  
Estos ejemplos prácticos facilitan el entendimiento de la integración de Loopback con diversos motores de base de datos, permitiendo adaptar la solución a diferentes requerimientos y escenarios.

== 6. Autenticación y Autorización

=== Implementación de estrategias de autenticación
Loopback permite integrar diversas estrategias de autenticación para validar la identidad de los usuarios. Esto puede incluir:
* Autenticación basada en sesiones y certificados.
* Uso de API keys para acceso restringido.
* Integración con proveedores externos (por ejemplo, LDAP o redes sociales).

La configuración se realiza mediante componentes que encapsulan la lógica de cada estrategia, permitiendo sustituir o combinar métodos según los requisitos del proyecto.

=== Uso de OAuth2 y JWT tokens
Para gestionar autorizaciones de manera segura y escalable, se recomienda:
* **OAuth2:** Establece un flujo seguro para que aplicaciones de terceros accedan a recursos protegidos. Configura proveedores de OAuth2 y define scopes de acceso.
* **JWT Tokens:** Se generan al autenticar a un usuario y se incluyen en las solicitudes subsiguientes para verificar la identidad y permisos. La validación del token se realiza en cada endpoint protegido, garantizando que sólo usuarios autorizados puedan acceder a determinados recursos.

La combinación de OAuth2 y JWT proporciona una solución robusta para la autenticación, permitiendo la delegación de credenciales y la administración simplificada de sesiones.

=== Gestión de roles y permisos
La autorización en Loopback se puede gestionar mediante la asignación de roles a los usuarios y la definición de permisos específicos para cada rol. Algunas prácticas incluyen:
* **Asignación de Roles:** Definir roles como administrador, usuario y invitado, y asignarlos durante la autenticación o en el proceso de registro.
* **Control de Acceso:** Implementar middleware o interceptores que verifiquen si el rol del usuario tiene permisos para ejecutar la acción solicitada.
* **Políticas de Seguridad:** Configurar restricciones a nivel de endpoint, modelo o método, permitiendo adaptar la autorización a los requerimientos de la aplicación.

Estas estrategias permiten crear una arquitectura segura y flexible para gestionar tanto la autenticación como la autorización en tus APIs.

== 7. Buenas Prácticas y Optimización

=== Manejo de errores y logging
Para garantizar la fiabilidad y mantenibilidad de la aplicación, es fundamental implementar un manejo de errores consistente y un sistema de logging robusto. Algunas recomendaciones incluyen:
* Uso de interceptores o middleware para capturar y formatear errores de forma centralizada.
* Registro de errores en archivos o sistemas de monitoreo para facilitar la depuración.
* Configuración de niveles de logging (debug, info, warn, error) acorde al entorno (desarrollo o producción).

Ejemplo de un interceptor para manejo de errores:
[source, javascript]
----
import {Interceptor, InvocationContext, InvocationResult} from '@loopback/context';
import {HttpErrors} from '@loopback/rest';

export class ErrorInterceptor implements Interceptor {
  async intercept(ctx: InvocationContext, next: () => Promise<InvocationResult>): Promise<InvocationResult> {
    try {
      return await next();
    } catch (err) {
      console.error('Error en la API:', err);
      throw new HttpErrors.InternalServerError('Error interno del servidor');
    }
  }
}
----

=== Optimización del rendimiento
Para mejorar el rendimiento de la aplicación se pueden aplicar diversas estrategias:
* Optimización de consultas a la base de datos mediante índices y consultas eficientes.
* Implementación de caching para respuestas frecuentes en endpoints críticos.
* Uso de procesos asíncronos y manejo adecuado de recursos para evitar bloqueos.
* Monitoreo y profiling de la aplicación para identificar y corregir cuellos de botella.

Estas técnicas ayudan a mantener tiempos de respuesta aceptables y a escalar la aplicación de manera eficiente.

=== Pruebas unitarias e integración continua
La calidad del código se garantiza mediante un robusto conjunto de pruebas:
* Pruebas unitarias: Se encargan de validar la funcionalidad aislada de cada componente (modelos, controladores, repositorios).
* Pruebas de integración: Verifican la correcta interacción entre componentes y el acceso a recursos externos.
* Integración continua (CI): Automatiza la ejecución de pruebas con cada cambio en el código, detectando errores de forma temprana y asegurando un despliegue confiable.

Ejemplo básico utilizando Mocha y Chai:
[source, javascript]
----
const {expect} = require('chai');
const {Calculator} = require('../src/calculator');

describe('Calculator', () => {
  it('should correctly add two numbers', () => {
    const calc = new Calculator();
    expect(calc.add(2, 3)).to.equal(5);
  });
});
----

Implementar estas prácticas contribuye a la creación de aplicaciones robustas, seguras y fáciles de mantener.